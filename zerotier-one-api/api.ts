/* tslint:disable */
/* eslint-disable */
/**
 * ZeroTierOne Service API
 * <p> This API controls the ZeroTier service that runs in the background on your computer. This is how zerotier-cli, and the macOS and Windows apps control the service. </p> <p> API requests must be authenticated via an authentication token. ZeroTier One saves this token in the authtoken.secret file in its working directory. This token may be supplied via the X-ZT1-Auth HTTP request header. </p> <p> For example: <code>curl -H \"X-ZT1-Auth: $TOKEN\" http://localhost:9993/status</code> </p> <p> The token can be found in: <ul> <li>Mac :: ~/Library/Application Support/ZeroTier/authtoken.secret</li> <li>Windows :: \\ProgramData\\ZeroTier\\One</li> <li>Linux :: /var/lib/zerotier-one</li> </ul> </p> <p> You can get the OpenAPI spec here as well: <code>https://docs.zerotier.com/openapi/servicev1.json</code></p>
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ControllerNetwork
 */
export interface ControllerNetwork {
    /**
     * 
     * @type {string}
     * @memberof ControllerNetwork
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControllerNetwork
     */
    'nwid'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControllerNetwork
     */
    'objtype'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControllerNetwork
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof ControllerNetwork
     */
    'creationTime'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ControllerNetwork
     */
    'private'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ControllerNetwork
     */
    'enableBroadcast'?: boolean;
    /**
     * 
     * @type {ControllerNetworkV4AssignMode}
     * @memberof ControllerNetwork
     */
    'v4AssignMode'?: ControllerNetworkV4AssignMode;
    /**
     * 
     * @type {ControllerNetworkV6AssignMode}
     * @memberof ControllerNetwork
     */
    'v6AssignMode'?: ControllerNetworkV6AssignMode;
    /**
     * 
     * @type {number}
     * @memberof ControllerNetwork
     */
    'mtu'?: number;
    /**
     * 
     * @type {number}
     * @memberof ControllerNetwork
     */
    'multicastLimit'?: number;
    /**
     * 
     * @type {number}
     * @memberof ControllerNetwork
     */
    'revision'?: number;
    /**
     * 
     * @type {Array<ControllerNetworkRoutesInner>}
     * @memberof ControllerNetwork
     */
    'routes'?: Array<ControllerNetworkRoutesInner>;
    /**
     * 
     * @type {Array<ControllerNetworkIpAssignmentPoolsInner>}
     * @memberof ControllerNetwork
     */
    'ipAssignmentPools'?: Array<ControllerNetworkIpAssignmentPoolsInner>;
    /**
     * 
     * @type {Array<object>}
     * @memberof ControllerNetwork
     */
    'rules'?: Array<object>;
    /**
     * 
     * @type {Array<object>}
     * @memberof ControllerNetwork
     */
    'capabilities'?: Array<object>;
    /**
     * 
     * @type {Array<object>}
     * @memberof ControllerNetwork
     */
    'tags'?: Array<object>;
    /**
     * 
     * @type {string}
     * @memberof ControllerNetwork
     */
    'remoteTraceTarget'?: string;
    /**
     * 
     * @type {number}
     * @memberof ControllerNetwork
     */
    'remoteTraceLevel'?: number;
}
/**
 * 
 * @export
 * @interface ControllerNetworkIpAssignmentPoolsInner
 */
export interface ControllerNetworkIpAssignmentPoolsInner {
    /**
     * 
     * @type {string}
     * @memberof ControllerNetworkIpAssignmentPoolsInner
     */
    'ipRangeStart'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControllerNetworkIpAssignmentPoolsInner
     */
    'ipRangeEnd'?: string;
}
/**
 * 
 * @export
 * @interface ControllerNetworkMember
 */
export interface ControllerNetworkMember {
    /**
     * 
     * @type {string}
     * @memberof ControllerNetworkMember
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControllerNetworkMember
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControllerNetworkMember
     */
    'nwid'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ControllerNetworkMember
     */
    'authorized'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ControllerNetworkMember
     */
    'activeBridge'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ControllerNetworkMember
     */
    'identity'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ControllerNetworkMember
     */
    'ipAssignments'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof ControllerNetworkMember
     */
    'revision'?: number;
    /**
     * 
     * @type {number}
     * @memberof ControllerNetworkMember
     */
    'vMajor'?: number;
    /**
     * 
     * @type {number}
     * @memberof ControllerNetworkMember
     */
    'vMinor'?: number;
    /**
     * 
     * @type {number}
     * @memberof ControllerNetworkMember
     */
    'vRev'?: number;
    /**
     * 
     * @type {number}
     * @memberof ControllerNetworkMember
     */
    'vProto'?: number;
}
/**
 * 
 * @export
 * @interface ControllerNetworkRoutesInner
 */
export interface ControllerNetworkRoutesInner {
    /**
     * 
     * @type {string}
     * @memberof ControllerNetworkRoutesInner
     */
    'target'?: string;
    /**
     * 
     * @type {string}
     * @memberof ControllerNetworkRoutesInner
     */
    'via'?: string | null;
}
/**
 * 
 * @export
 * @interface ControllerNetworkV4AssignMode
 */
export interface ControllerNetworkV4AssignMode {
    /**
     * 
     * @type {boolean}
     * @memberof ControllerNetworkV4AssignMode
     */
    'zt'?: boolean;
}
/**
 * 
 * @export
 * @interface ControllerNetworkV6AssignMode
 */
export interface ControllerNetworkV6AssignMode {
    /**
     * 
     * @type {boolean}
     * @memberof ControllerNetworkV6AssignMode
     */
    '6plane'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ControllerNetworkV6AssignMode
     */
    'rfc4193'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ControllerNetworkV6AssignMode
     */
    'zt'?: boolean;
}
/**
 * 
 * @export
 * @interface ControllerStatus
 */
export interface ControllerStatus {
    /**
     * 
     * @type {boolean}
     * @memberof ControllerStatus
     */
    'controller'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ControllerStatus
     */
    'apiVersion'?: number;
    /**
     * 
     * @type {number}
     * @memberof ControllerStatus
     */
    'clock'?: number;
}
/**
 * 
 * @export
 * @interface Network
 */
export interface Network {
    /**
     * Let ZeroTier modify the system\'s DNS settings.
     * @type {boolean}
     * @memberof Network
     */
    'allowDNS'?: boolean;
    /**
     * Let ZeroTier modify the system\'s default route.
     * @type {boolean}
     * @memberof Network
     */
    'allowDefault'?: boolean;
    /**
     * Let ZeroTier manage IP addresses and Route assignments that aren\'t in private ranges (rfc1918).
     * @type {boolean}
     * @memberof Network
     */
    'allowGlobal'?: boolean;
    /**
     * Let ZeroTier to manage IP addresses and Route assignments.
     * @type {boolean}
     * @memberof Network
     */
    'allowManaged'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof Network
     */
    'assignedAddresses'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof Network
     */
    'bridge'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Network
     */
    'broadcastEnabled'?: boolean;
    /**
     * 
     * @type {NetworkAllOf1Dns}
     * @memberof Network
     */
    'dns'?: NetworkAllOf1Dns;
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    'id'?: string;
    /**
     * MAC address for this network\'s interface.
     * @type {string}
     * @memberof Network
     */
    'mac'?: string;
    /**
     * 
     * @type {number}
     * @memberof Network
     */
    'mtu'?: number;
    /**
     * 
     * @type {Array<NetworkAllOf1MulticastSubscriptions>}
     * @memberof Network
     */
    'multicastSubscriptions'?: Array<NetworkAllOf1MulticastSubscriptions>;
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof Network
     */
    'netconfRevision'?: number;
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    'portDeviceName'?: string;
    /**
     * 
     * @type {number}
     * @memberof Network
     */
    'portError'?: number;
    /**
     * 
     * @type {Array<object>}
     * @memberof Network
     */
    'routes'?: Array<object>;
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface NetworkAllOf
 */
export interface NetworkAllOf {
    /**
     * Let ZeroTier modify the system\'s DNS settings.
     * @type {boolean}
     * @memberof NetworkAllOf
     */
    'allowDNS'?: boolean;
    /**
     * Let ZeroTier modify the system\'s default route.
     * @type {boolean}
     * @memberof NetworkAllOf
     */
    'allowDefault'?: boolean;
    /**
     * Let ZeroTier manage IP addresses and route assignments that aren\'t in private ranges (rfc1918).
     * @type {boolean}
     * @memberof NetworkAllOf
     */
    'allowGlobal'?: boolean;
    /**
     * Let ZeroTier manage IP addresses and Route assignments.
     * @type {boolean}
     * @memberof NetworkAllOf
     */
    'allowManaged'?: boolean;
}
/**
 * 
 * @export
 * @interface NetworkAllOf1
 */
export interface NetworkAllOf1 {
    /**
     * Let ZeroTier modify the system\'s DNS settings.
     * @type {boolean}
     * @memberof NetworkAllOf1
     */
    'allowDNS'?: boolean;
    /**
     * Let ZeroTier modify the system\'s default route.
     * @type {boolean}
     * @memberof NetworkAllOf1
     */
    'allowDefault'?: boolean;
    /**
     * Let ZeroTier manage IP addresses and Route assignments that aren\'t in private ranges (rfc1918).
     * @type {boolean}
     * @memberof NetworkAllOf1
     */
    'allowGlobal'?: boolean;
    /**
     * Let ZeroTier to manage IP addresses and Route assignments.
     * @type {boolean}
     * @memberof NetworkAllOf1
     */
    'allowManaged'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof NetworkAllOf1
     */
    'assignedAddresses'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof NetworkAllOf1
     */
    'bridge'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof NetworkAllOf1
     */
    'broadcastEnabled'?: boolean;
    /**
     * 
     * @type {NetworkAllOf1Dns}
     * @memberof NetworkAllOf1
     */
    'dns'?: NetworkAllOf1Dns;
    /**
     * 
     * @type {string}
     * @memberof NetworkAllOf1
     */
    'id'?: string;
    /**
     * MAC address for this network\'s interface.
     * @type {string}
     * @memberof NetworkAllOf1
     */
    'mac'?: string;
    /**
     * 
     * @type {number}
     * @memberof NetworkAllOf1
     */
    'mtu'?: number;
    /**
     * 
     * @type {Array<NetworkAllOf1MulticastSubscriptions>}
     * @memberof NetworkAllOf1
     */
    'multicastSubscriptions'?: Array<NetworkAllOf1MulticastSubscriptions>;
    /**
     * 
     * @type {string}
     * @memberof NetworkAllOf1
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof NetworkAllOf1
     */
    'netconfRevision'?: number;
    /**
     * 
     * @type {string}
     * @memberof NetworkAllOf1
     */
    'portDeviceName'?: string;
    /**
     * 
     * @type {number}
     * @memberof NetworkAllOf1
     */
    'portError'?: number;
    /**
     * 
     * @type {Array<object>}
     * @memberof NetworkAllOf1
     */
    'routes'?: Array<object>;
    /**
     * 
     * @type {string}
     * @memberof NetworkAllOf1
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkAllOf1
     */
    'type'?: string;
}
/**
 * 
 * @export
 * @interface NetworkAllOf1Dns
 */
export interface NetworkAllOf1Dns {
    /**
     * 
     * @type {string}
     * @memberof NetworkAllOf1Dns
     */
    'domain'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof NetworkAllOf1Dns
     */
    'servers'?: Array<string>;
}
/**
 * 
 * @export
 * @interface NetworkAllOf1MulticastSubscriptions
 */
export interface NetworkAllOf1MulticastSubscriptions {
    /**
     * 
     * @type {number}
     * @memberof NetworkAllOf1MulticastSubscriptions
     */
    'adi'?: number;
    /**
     * 
     * @type {string}
     * @memberof NetworkAllOf1MulticastSubscriptions
     */
    'mac'?: string;
}
/**
 * 
 * @export
 * @interface Peer
 */
export interface Peer {
    /**
     * 
     * @type {string}
     * @memberof Peer
     */
    'address'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Peer
     */
    'isBonded'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Peer
     */
    'latency'?: number;
    /**
     * 
     * @type {Array<PeerPathsInner>}
     * @memberof Peer
     */
    'paths'?: Array<PeerPathsInner>;
    /**
     * 
     * @type {string}
     * @memberof Peer
     */
    'role'?: string;
    /**
     * 
     * @type {string}
     * @memberof Peer
     */
    'version'?: string;
    /**
     * 
     * @type {number}
     * @memberof Peer
     */
    'versionMajor'?: number;
    /**
     * 
     * @type {number}
     * @memberof Peer
     */
    'versionMinor'?: number;
    /**
     * 
     * @type {number}
     * @memberof Peer
     */
    'versionRev'?: number;
}
/**
 * 
 * @export
 * @interface PeerPathsInner
 */
export interface PeerPathsInner {
    /**
     * 
     * @type {boolean}
     * @memberof PeerPathsInner
     */
    'active'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PeerPathsInner
     */
    'address'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof PeerPathsInner
     */
    'expired'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PeerPathsInner
     */
    'lastReceive'?: number;
    /**
     * 
     * @type {number}
     * @memberof PeerPathsInner
     */
    'lastSend'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PeerPathsInner
     */
    'preferred'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PeerPathsInner
     */
    'trustedPathId'?: number;
}
/**
 * 
 * @export
 * @interface Status
 */
export interface Status {
    /**
     * 
     * @type {string}
     * @memberof Status
     */
    'address'?: string;
    /**
     * 
     * @type {number}
     * @memberof Status
     */
    'clock'?: number;
    /**
     * 
     * @type {StatusConfig}
     * @memberof Status
     */
    'config'?: StatusConfig;
    /**
     * 
     * @type {boolean}
     * @memberof Status
     */
    'online'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Status
     */
    'planetWorldId'?: number;
    /**
     * 
     * @type {number}
     * @memberof Status
     */
    'planetWorldTimestamp'?: number;
    /**
     * 
     * @type {string}
     * @memberof Status
     */
    'publicIdentity'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Status
     */
    'tcpFallbackActive'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Status
     */
    'version'?: string;
    /**
     * 
     * @type {number}
     * @memberof Status
     */
    'versionBuild'?: number;
    /**
     * 
     * @type {number}
     * @memberof Status
     */
    'versionMajor'?: number;
    /**
     * 
     * @type {number}
     * @memberof Status
     */
    'versionMinor'?: number;
    /**
     * 
     * @type {number}
     * @memberof Status
     */
    'versionRev'?: number;
}
/**
 * 
 * @export
 * @interface StatusConfig
 */
export interface StatusConfig {
    /**
     * 
     * @type {StatusConfigSettings}
     * @memberof StatusConfig
     */
    'settings'?: StatusConfigSettings;
}
/**
 * 
 * @export
 * @interface StatusConfigSettings
 */
export interface StatusConfigSettings {
    /**
     * 
     * @type {boolean}
     * @memberof StatusConfigSettings
     */
    'allowTcpFallbackRelay'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StatusConfigSettings
     */
    'portMappingEnabled'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof StatusConfigSettings
     */
    'primaryPort'?: number;
}

/**
 * ControllerApi - axios parameter creator
 * @export
 */
export const ControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create a new network with a random ID.
         * @summary Generate Random Network ID.
         * @param {string} controllerID Node ID of the controller.
         * @param {ControllerNetwork} controllerNetwork Network object JSON.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateControllerNetwork: async (controllerID: string, controllerNetwork: ControllerNetwork, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'controllerID' is not null or undefined
            assertParamExists('generateControllerNetwork', 'controllerID', controllerID)
            // verify required parameter 'controllerNetwork' is not null or undefined
            assertParamExists('generateControllerNetwork', 'controllerNetwork', controllerNetwork)
            const localVarPath = `/controller/network/{controllerID}______`
                .replace(`{${"controllerID"}}`, encodeURIComponent(String(controllerID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-ZT1-Auth", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(controllerNetwork, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get details of a network by it\'s ID.
         * @summary Get Network by ID.
         * @param {string} networkID ID of the network.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getControllerNetwork: async (networkID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkID' is not null or undefined
            assertParamExists('getControllerNetwork', 'networkID', networkID)
            const localVarPath = `/controller/network/{networkID}`
                .replace(`{${"networkID"}}`, encodeURIComponent(String(networkID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-ZT1-Auth", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Network Member Details by ID.
         * @param {string} networkID ID of the network.
         * @param {string} nodeID ID of the member node.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getControllerNetworkMember: async (networkID: string, nodeID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkID' is not null or undefined
            assertParamExists('getControllerNetworkMember', 'networkID', networkID)
            // verify required parameter 'nodeID' is not null or undefined
            assertParamExists('getControllerNetworkMember', 'nodeID', nodeID)
            const localVarPath = `/controller/network/{networkID}/member/{nodeID}`
                .replace(`{${"networkID"}}`, encodeURIComponent(String(networkID)))
                .replace(`{${"nodeID"}}`, encodeURIComponent(String(nodeID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-ZT1-Auth", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * JSON object containing all member IDs as keys and their memberRevisionCounter values as values.
         * @summary List Network Members.
         * @param {string} networkID ID of the network.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getControllerNetworkMembers: async (networkID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkID' is not null or undefined
            assertParamExists('getControllerNetworkMembers', 'networkID', networkID)
            const localVarPath = `/controller/network/{networkID}/member`
                .replace(`{${"networkID"}}`, encodeURIComponent(String(networkID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-ZT1-Auth", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List IDs of all networks hosted by this controller.
         * @summary List Networks.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getControllerNetworks: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/controller/network`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-ZT1-Auth", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check for controller function and return controller status.
         * @summary Get Controller Status.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getControllerStatus: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/controller`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-ZT1-Auth", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Create or Update a Network.
         * @param {string} networkID ID of the network.
         * @param {ControllerNetwork} controllerNetwork Network object JSON.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setControllerNetwork: async (networkID: string, controllerNetwork: ControllerNetwork, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkID' is not null or undefined
            assertParamExists('setControllerNetwork', 'networkID', networkID)
            // verify required parameter 'controllerNetwork' is not null or undefined
            assertParamExists('setControllerNetwork', 'controllerNetwork', controllerNetwork)
            const localVarPath = `/controller/network/{networkID}`
                .replace(`{${"networkID"}}`, encodeURIComponent(String(networkID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-ZT1-Auth", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(controllerNetwork, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ControllerApi - functional programming interface
 * @export
 */
export const ControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * Create a new network with a random ID.
         * @summary Generate Random Network ID.
         * @param {string} controllerID Node ID of the controller.
         * @param {ControllerNetwork} controllerNetwork Network object JSON.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateControllerNetwork(controllerID: string, controllerNetwork: ControllerNetwork, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ControllerNetwork>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateControllerNetwork(controllerID, controllerNetwork, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get details of a network by it\'s ID.
         * @summary Get Network by ID.
         * @param {string} networkID ID of the network.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getControllerNetwork(networkID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ControllerNetwork>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getControllerNetwork(networkID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Network Member Details by ID.
         * @param {string} networkID ID of the network.
         * @param {string} nodeID ID of the member node.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getControllerNetworkMember(networkID: string, nodeID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ControllerNetworkMember>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getControllerNetworkMember(networkID, nodeID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * JSON object containing all member IDs as keys and their memberRevisionCounter values as values.
         * @summary List Network Members.
         * @param {string} networkID ID of the network.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getControllerNetworkMembers(networkID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: number; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getControllerNetworkMembers(networkID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List IDs of all networks hosted by this controller.
         * @summary List Networks.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getControllerNetworks(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getControllerNetworks(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Check for controller function and return controller status.
         * @summary Get Controller Status.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getControllerStatus(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ControllerStatus>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getControllerStatus(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Create or Update a Network.
         * @param {string} networkID ID of the network.
         * @param {ControllerNetwork} controllerNetwork Network object JSON.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setControllerNetwork(networkID: string, controllerNetwork: ControllerNetwork, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ControllerNetwork>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setControllerNetwork(networkID, controllerNetwork, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ControllerApi - factory interface
 * @export
 */
export const ControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ControllerApiFp(configuration)
    return {
        /**
         * Create a new network with a random ID.
         * @summary Generate Random Network ID.
         * @param {string} controllerID Node ID of the controller.
         * @param {ControllerNetwork} controllerNetwork Network object JSON.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateControllerNetwork(controllerID: string, controllerNetwork: ControllerNetwork, options?: any): AxiosPromise<ControllerNetwork> {
            return localVarFp.generateControllerNetwork(controllerID, controllerNetwork, options).then((request) => request(axios, basePath));
        },
        /**
         * Get details of a network by it\'s ID.
         * @summary Get Network by ID.
         * @param {string} networkID ID of the network.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getControllerNetwork(networkID: string, options?: any): AxiosPromise<ControllerNetwork> {
            return localVarFp.getControllerNetwork(networkID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Network Member Details by ID.
         * @param {string} networkID ID of the network.
         * @param {string} nodeID ID of the member node.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getControllerNetworkMember(networkID: string, nodeID: string, options?: any): AxiosPromise<ControllerNetworkMember> {
            return localVarFp.getControllerNetworkMember(networkID, nodeID, options).then((request) => request(axios, basePath));
        },
        /**
         * JSON object containing all member IDs as keys and their memberRevisionCounter values as values.
         * @summary List Network Members.
         * @param {string} networkID ID of the network.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getControllerNetworkMembers(networkID: string, options?: any): AxiosPromise<{ [key: string]: number; }> {
            return localVarFp.getControllerNetworkMembers(networkID, options).then((request) => request(axios, basePath));
        },
        /**
         * List IDs of all networks hosted by this controller.
         * @summary List Networks.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getControllerNetworks(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getControllerNetworks(options).then((request) => request(axios, basePath));
        },
        /**
         * Check for controller function and return controller status.
         * @summary Get Controller Status.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getControllerStatus(options?: any): AxiosPromise<ControllerStatus> {
            return localVarFp.getControllerStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Create or Update a Network.
         * @param {string} networkID ID of the network.
         * @param {ControllerNetwork} controllerNetwork Network object JSON.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setControllerNetwork(networkID: string, controllerNetwork: ControllerNetwork, options?: any): AxiosPromise<ControllerNetwork> {
            return localVarFp.setControllerNetwork(networkID, controllerNetwork, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ControllerApi - object-oriented interface
 * @export
 * @class ControllerApi
 * @extends {BaseAPI}
 */
export class ControllerApi extends BaseAPI {
    /**
     * Create a new network with a random ID.
     * @summary Generate Random Network ID.
     * @param {string} controllerID Node ID of the controller.
     * @param {ControllerNetwork} controllerNetwork Network object JSON.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ControllerApi
     */
    public generateControllerNetwork(controllerID: string, controllerNetwork: ControllerNetwork, options?: AxiosRequestConfig) {
        return ControllerApiFp(this.configuration).generateControllerNetwork(controllerID, controllerNetwork, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get details of a network by it\'s ID.
     * @summary Get Network by ID.
     * @param {string} networkID ID of the network.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ControllerApi
     */
    public getControllerNetwork(networkID: string, options?: AxiosRequestConfig) {
        return ControllerApiFp(this.configuration).getControllerNetwork(networkID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Network Member Details by ID.
     * @param {string} networkID ID of the network.
     * @param {string} nodeID ID of the member node.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ControllerApi
     */
    public getControllerNetworkMember(networkID: string, nodeID: string, options?: AxiosRequestConfig) {
        return ControllerApiFp(this.configuration).getControllerNetworkMember(networkID, nodeID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * JSON object containing all member IDs as keys and their memberRevisionCounter values as values.
     * @summary List Network Members.
     * @param {string} networkID ID of the network.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ControllerApi
     */
    public getControllerNetworkMembers(networkID: string, options?: AxiosRequestConfig) {
        return ControllerApiFp(this.configuration).getControllerNetworkMembers(networkID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List IDs of all networks hosted by this controller.
     * @summary List Networks.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ControllerApi
     */
    public getControllerNetworks(options?: AxiosRequestConfig) {
        return ControllerApiFp(this.configuration).getControllerNetworks(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check for controller function and return controller status.
     * @summary Get Controller Status.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ControllerApi
     */
    public getControllerStatus(options?: AxiosRequestConfig) {
        return ControllerApiFp(this.configuration).getControllerStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Create or Update a Network.
     * @param {string} networkID ID of the network.
     * @param {ControllerNetwork} controllerNetwork Network object JSON.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ControllerApi
     */
    public setControllerNetwork(networkID: string, controllerNetwork: ControllerNetwork, options?: AxiosRequestConfig) {
        return ControllerApiFp(this.configuration).setControllerNetwork(networkID, controllerNetwork, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NetworkApi - axios parameter creator
 * @export
 */
export const NetworkApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Leave a network.
         * @param {string} networkID ID of the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNetwork: async (networkID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkID' is not null or undefined
            assertParamExists('deleteNetwork', 'networkID', networkID)
            const localVarPath = `/network/{networkID}`
                .replace(`{${"networkID"}}`, encodeURIComponent(String(networkID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-ZT1-Auth", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a joined Network membership configuration by Network ID.
         * @param {string} networkID ID of the network to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetwork: async (networkID: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkID' is not null or undefined
            assertParamExists('getNetwork', 'networkID', networkID)
            const localVarPath = `/network/{networkID}`
                .replace(`{${"networkID"}}`, encodeURIComponent(String(networkID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-ZT1-Auth", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all network memberships.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworks: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/network`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-ZT1-Auth", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Join a network or update it\'s configuration by Network ID.
         * @param {string} networkID ID of the network to change.
         * @param {Network} network Network membership object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNetwork: async (networkID: string, network: Network, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkID' is not null or undefined
            assertParamExists('updateNetwork', 'networkID', networkID)
            // verify required parameter 'network' is not null or undefined
            assertParamExists('updateNetwork', 'network', network)
            const localVarPath = `/network/{networkID}`
                .replace(`{${"networkID"}}`, encodeURIComponent(String(networkID)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-ZT1-Auth", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(network, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NetworkApi - functional programming interface
 * @export
 */
export const NetworkApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NetworkApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Leave a network.
         * @param {string} networkID ID of the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteNetwork(networkID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteNetwork(networkID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get a joined Network membership configuration by Network ID.
         * @param {string} networkID ID of the network to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNetwork(networkID: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Network>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNetwork(networkID, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all network memberships.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNetworks(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Network>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNetworks(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Join a network or update it\'s configuration by Network ID.
         * @param {string} networkID ID of the network to change.
         * @param {Network} network Network membership object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateNetwork(networkID: string, network: Network, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Network>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateNetwork(networkID, network, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NetworkApi - factory interface
 * @export
 */
export const NetworkApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NetworkApiFp(configuration)
    return {
        /**
         * 
         * @summary Leave a network.
         * @param {string} networkID ID of the network
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteNetwork(networkID: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteNetwork(networkID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a joined Network membership configuration by Network ID.
         * @param {string} networkID ID of the network to get.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetwork(networkID: string, options?: any): AxiosPromise<Network> {
            return localVarFp.getNetwork(networkID, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all network memberships.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworks(options?: any): AxiosPromise<Array<Network>> {
            return localVarFp.getNetworks(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Join a network or update it\'s configuration by Network ID.
         * @param {string} networkID ID of the network to change.
         * @param {Network} network Network membership object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNetwork(networkID: string, network: Network, options?: any): AxiosPromise<Network> {
            return localVarFp.updateNetwork(networkID, network, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NetworkApi - object-oriented interface
 * @export
 * @class NetworkApi
 * @extends {BaseAPI}
 */
export class NetworkApi extends BaseAPI {
    /**
     * 
     * @summary Leave a network.
     * @param {string} networkID ID of the network
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkApi
     */
    public deleteNetwork(networkID: string, options?: AxiosRequestConfig) {
        return NetworkApiFp(this.configuration).deleteNetwork(networkID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a joined Network membership configuration by Network ID.
     * @param {string} networkID ID of the network to get.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkApi
     */
    public getNetwork(networkID: string, options?: AxiosRequestConfig) {
        return NetworkApiFp(this.configuration).getNetwork(networkID, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all network memberships.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkApi
     */
    public getNetworks(options?: AxiosRequestConfig) {
        return NetworkApiFp(this.configuration).getNetworks(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Join a network or update it\'s configuration by Network ID.
     * @param {string} networkID ID of the network to change.
     * @param {Network} network Network membership object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkApi
     */
    public updateNetwork(networkID: string, network: Network, options?: AxiosRequestConfig) {
        return NetworkApiFp(this.configuration).updateNetwork(networkID, network, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PeerApi - axios parameter creator
 * @export
 */
export const PeerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get information about a specific peer by Node ID.
         * @param {string} address ZeroTier address of the peer to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPeer: async (address: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getPeer', 'address', address)
            const localVarPath = `/peer/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-ZT1-Auth", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all peers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPeers: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/peer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-ZT1-Auth", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PeerApi - functional programming interface
 * @export
 */
export const PeerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PeerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get information about a specific peer by Node ID.
         * @param {string} address ZeroTier address of the peer to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPeer(address: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Peer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPeer(address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all peers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPeers(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Peer>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPeers(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PeerApi - factory interface
 * @export
 */
export const PeerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PeerApiFp(configuration)
    return {
        /**
         * 
         * @summary Get information about a specific peer by Node ID.
         * @param {string} address ZeroTier address of the peer to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPeer(address: string, options?: any): AxiosPromise<Peer> {
            return localVarFp.getPeer(address, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all peers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPeers(options?: any): AxiosPromise<Array<Peer>> {
            return localVarFp.getPeers(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PeerApi - object-oriented interface
 * @export
 * @class PeerApi
 * @extends {BaseAPI}
 */
export class PeerApi extends BaseAPI {
    /**
     * 
     * @summary Get information about a specific peer by Node ID.
     * @param {string} address ZeroTier address of the peer to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeerApi
     */
    public getPeer(address: string, options?: AxiosRequestConfig) {
        return PeerApiFp(this.configuration).getPeer(address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all peers.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeerApi
     */
    public getPeers(options?: AxiosRequestConfig) {
        return PeerApiFp(this.configuration).getPeers(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StatusApi - axios parameter creator
 * @export
 */
export const StatusApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Node status and addressing info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-ZT1-Auth", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StatusApi - functional programming interface
 * @export
 */
export const StatusApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StatusApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Node status and addressing info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatus(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Status>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatus(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StatusApi - factory interface
 * @export
 */
export const StatusApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StatusApiFp(configuration)
    return {
        /**
         * 
         * @summary Node status and addressing info.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus(options?: any): AxiosPromise<Status> {
            return localVarFp.getStatus(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StatusApi - object-oriented interface
 * @export
 * @class StatusApi
 * @extends {BaseAPI}
 */
export class StatusApi extends BaseAPI {
    /**
     * 
     * @summary Node status and addressing info.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StatusApi
     */
    public getStatus(options?: AxiosRequestConfig) {
        return StatusApiFp(this.configuration).getStatus(options).then((request) => request(this.axios, this.basePath));
    }
}


